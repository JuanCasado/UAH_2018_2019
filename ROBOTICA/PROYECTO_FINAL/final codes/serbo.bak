#define MOTORBRAZO OUT_B
#define MOTORPINZA OUT_A
#define MOTORBARRENA OUT_C
#define BRAZOKP 1
#define BRAZOKI 0.001
#define PINZAKP 0.055
#define PINZAKI 0.0001
#define BARRENAKP 0.055
#define BARRENAKI 0.0001
#define MAX_VEL 90
#define MAX_VELBARRENA 20
//blu
#include "NXCDefs.h"

#define BT_CONN_BASE 0 // BASE
#define INBOX 1
#define OUTBOX 5
/* Angulos pinza */
#define ANGULOBRAZO90 333
#define ANGULOPINZACERRAR 3400
#define ANGULOPINZAMEDIOABIERTO 2800
#define ANGULOBRAZO45 208
#define ANGULOBARRENADESPLEGADA 1500
//por defecto 0
//mover despacio
//abierto entero 1500
//parar cuando toque en el vamper
#define MARGEN 5

/*
sub BTCheck(int conn){
               if(!BluetoothStatus(conn)==NO_ERR){
                 TextOut(5,LCD_LINE5,"Error");
                 Wait(1000);
                 Stop(true);
                }
}
//Master
int recibir(int bt_conn){
     int in;
     //BTCheck(bt_conn); //check master connection
     ReceiveRemoteNumber(INBOX,true,in);
     return in;
}
//Slave

void mandar(int msg, int bt_conn){
     BTCheck(bt_conn);
     SendRemoteNumber(bt_conn, OUTBOX, msg);

}
  */
//CODE

mutex semaforoAccion;
mutex semaforoPinza;
mutex semaforoBrazo;
mutex semaforoBarrena;

long anguloActualBrazo = 0;
long anguloActualPinza = 0;
long anguloActualBarrena = 0;
long anguloBrazo = 0;
long anguloPinza = 0;
long anguloBarrena = 0;


int constraint (int valor, int max, int min){
    if(valor > max) {
     return max;
    }
    if (valor < min)
    {
     return min;
    }
    return valor;
}



void setAnguloBrazo(long angulo)
{
        Acquire(semaforoBrazo);
        anguloBrazo = angulo;
        Release(semaforoBrazo);
}

void setAnguloPinza(long angulo)
{
        Acquire(semaforoPinza);
        anguloPinza = angulo;
        Release(semaforoPinza);
}

void setAnguloBarrena(long angulo)
{
        Acquire(semaforoBarrena);
        anguloBarrena = angulo;
        Release(semaforoBarrena);
}

task posicion()
{
     while(true)
     {
        Acquire(semaforoBrazo);
        anguloActualBrazo = MotorRotationCount(MOTORBRAZO);
        NumOut(1, LCD_LINE1, anguloActualBrazo);
        Release(semaforoBrazo);
        Acquire(semaforoPinza);
        anguloActualPinza = MotorRotationCount(MOTORPINZA);
        NumOut(1, LCD_LINE2, anguloActualPinza);
        Release(semaforoPinza);
        Acquire(semaforoBarrena);
        anguloActualBarrena = MotorRotationCount(MOTORBARRENA);
        NumOut(1, LCD_LINE3, anguloActualBarrena);
        Release(semaforoBarrena);

     }
}

bool checkAngulo(long angulo1, long angulo2)
{

 if(abs(angulo1 - angulo2) < MARGEN)
 {
   return true;
 } else {
   return false;
 }
}
void moverBrazoPosDeseada(int motor, long angulo, float kp, float ki, long anguloActual)
{
     float error = angulo- anguloActual ;
     float integral = integral + error;
     float constantes = kp*error + ki*integral;
     int velocidad = constantes;
     OnFwd(motor, constraint(velocidad, MAX_VEL, -MAX_VEL));
     NumOut(1, LCD_LINE1, angulo);
     NumOut(1, LCD_LINE2, anguloActual);
     //checkAngulo(angulo, anguloActual);

}

void moverBrazo(int motor, long anguloDeseado,float kp,float ki, long anguloActual)
{

       Acquire(semaforoBrazo);
       //moverBrazoPosDeseada(motor, ANGULOINICIAL-anguloDeseado, kp, ki, anguloActual);
       moverBrazoPosDeseada(motor, anguloDeseado, kp, ki, anguloActual);
       Release(semaforoBrazo);
}

void moverPinza(int motor, long anguloDeseado,float kp,float ki, long anguloActual)
{
       Acquire(semaforoPinza);
       moverBrazoPosDeseada(motor, anguloDeseado, kp, ki, anguloActual);
       Release(semaforoPinza);
}

task movimiento()
{
     long errorBrazo, errorPinza, errorBarrena;
     float integralBrazo, integralPinza, integralBarrena;
     float constantesBrazo, constantesPinza, constantesBarrena;
     int velocidadBrazo, velocidadPinza, velocidadBarrena;
     while(true)
     {
      // Calculo velocidad motor Brazo
      Acquire(semaforoBrazo);
      errorBrazo = anguloBrazo - anguloActualBrazo ;
      Release(semaforoBrazo);
      integralBrazo = integralBrazo + errorBrazo;
      constantesBrazo = BRAZOKP*errorBrazo + BRAZOKI*integralBrazo;
      velocidadBrazo = constantesBrazo;
      // Calculo velocidad motor Pinza
      Acquire(semaforoPinza);
      errorPinza = anguloPinza - anguloActualPinza ;
      Release(semaforoPinza);
      integralPinza = integralPinza + errorPinza;
      constantesPinza = PINZAKP*errorPinza + PINZAKI*integralPinza;
      velocidadPinza = constantesPinza;
      // Calculo velocidad motor Barrena
      Acquire(semaforoBarrena);
      errorBarrena = anguloBarrena - anguloActualBarrena ;
      Release(semaforoBarrena);
      integralBarrena = integralBarrena + errorBarrena;
      constantesBarrena = BARRENAKP*errorBarrena + BARRENAKI*integralBarrena;
      velocidadBarrena = constantesBarrena;
      // Set motores
      OnFwd(MOTORBRAZO, constraint(velocidadBrazo, MAX_VEL, -MAX_VEL));
      OnFwd(MOTORPINZA, constraint(velocidadPinza, MAX_VEL, -MAX_VEL));
      OnFwd(MOTORBARRENA, constraint(velocidadBarrena, MAX_VELBARRENA, -MAX_VELBARRENA));
     //moverBrazo(MOTORBRAZO, anguloBrazo, BRAZOKP, BRAZOKI,anguloActualBrazo);
     //moverPinza(MOTORPINZA, anguloPinza, PINZAKP, PINZAKI,anguloActualPinza);
     }
}
/*
int phase = 1;
void nextPhase()
{
    //Acquire(sMovimiento);
    mandar(phase, BT_CONN_BASE);
    bool esperar = true;
    while(esperar)
     {
        if (recibir(BT_CONN_BASE) == 0)
        {
         esperar = false;
        }
     }

     phase++;
     //Release(sMovimiento);
} */

void esperar(int num)
{
 bool bucle = true;
 switch(num)
 {
  case 0:
  while(bucle)
  {
   Acquire(semaforoBrazo);
   if(checkAngulo(anguloBrazo, anguloActualBrazo)){
    bucle = false;
   }
   Release(semaforoBrazo);
  }
  break;
  case 1:
  while(bucle)
  {
   Acquire(semaforoPinza);
   if(checkAngulo(anguloPinza, anguloActualPinza)){
    bucle = false;
   }
   Release(semaforoPinza);
  }
  break;
  case 2:
  while(bucle)
  {
   Acquire(semaforoBarrena);
   if(checkAngulo(anguloBarrena, anguloActualBarrena)){
    bucle = false;
   }
   Release(semaforoBarrena);
  }
  break;
 }

}

void recogerFicha()
{
     //Empieza arriba
     //baja brazo 90
     //Acquire(semaforoAccion);

     setAnguloBrazo(ANGULOBRAZO90);
     esperar(0);

     //cierra pinza
     //Acquire(semaforoAccion);

     setAnguloPinza(ANGULOPINZACERRAR);
     esperar(1);

     //brazo sube
     //Acquire(semaforoAccion);

     setAnguloBrazo(0);
     esperar(0);

     //abrir pinza  mitad
     //Acquire(semaforoAccion);

     setAnguloPinza(ANGULOPINZAMEDIOABIERTO);
     esperar(1);

     //bajar brazo 45º
     //Acquire(semaforoAccion);

     setAnguloBrazo(ANGULOBRAZO45);
     esperar(0);

     //terminar abrir pinnza
     //Acquire(semaforoAccion);

     setAnguloPinza(0);
     esperar(1);

     //barrea delante
     //Acquire(semaforoAccion);

     setAnguloBarrena(ANGULOBARRENADESPLEGADA);
     esperar(2);

     //subir brazo arriba
     //Acquire(semaforoAccion);

     setAnguloBrazo(0);
     esperar(0);

     //mover deslizador hacia atras
     setAnguloBarrena(0);
     esperar(2);
     
}

task test()
{

     recogerFicha();





     //Wait(5000);
     //recogerFicha();
     //Wait(5000);
     //setAnguloBrazo(250);
     //Wait(5000);
     /*setAnguloPinza(ANGULOPINZACERRAR);

     Wait(10000);
     setAnguloPinza(0);
     Wait(10000);
     //setAnguloBrazo(10);

     Wait(10000); */
     //nextPhase();
     //setAnguloPinza(-1500);
     //setAnguloBrazo(600);
     //Wait(5000);
     //setAnguloPinza(-200) ;
     //setAnguloBrazo(50);
     //Wait(2000);
     //setAnguloPinza(-300);
     //Wait(5000);
     //setAnguloBrazo(0);

}
task main()
{
     Precedes(posicion, movimiento, test);
}

