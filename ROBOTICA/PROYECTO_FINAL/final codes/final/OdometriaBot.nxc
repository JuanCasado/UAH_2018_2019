#define RADIO 0.03
#define D 0.158
#define THRESHOLD 50
#define KP 0
#define KI 0
#define MOTORDER OUT_A
#define MOTORIZQ OUT_C
//Unknow
#define PX 3
#define IX 0
#define DX 0
#define PY 0
#define IY 0
#define DY 0
// Constantes de Giro
#define PG 3
#define IG 0
#define DG 0
#define MARGIN 5



#define TIME 20
#define MAX_ACC 50
#define MAX_VEL 100
#define MAX_GO 75

/*Time*/



/*CODE*/



int constraint (int valor, int max, int min){
    if(valor > max) {
     return max;
    }
    if (valor < min)
    {
     return min;
    }
    return valor;
}

float constr (float valor, float max, float min)
{
      if (valor > max)
         return max;
      if (valor < min)
         return min;
      return valor;
}

mutex semaforo;
mutex sMovimiento;
float x = 0;
float y = 0;
float angle = 0;
float dist = 0;
//Variables destino
float xDestino = 0;
float yDestino = 0;
// Arrays de movimiento para irA
float movFichas1X [4] = {100 , 0, 20, 0};
float movFichas1Y [4] = {0 , 157, 0, 157};
int movFichas1Tam = 4;
int phase = 1;



// Rellenar con mas arrays

void move()
{
     int nextMovement = 0;
     float arrayX [4] = {40 , 40, 80, 80};
     float arrayY [4] = {0 , 314, 314, 628};
     int tam = 4;
     //float movementsX [] = {};
     //float movementsY [8] = {};
     float errorX = 0;
     float error_anteriorX = 0;
     float error_accX = 0;
     float to_doX = 0;
     float errorY = 0;
     float error_anteriorY = 0;
     float error_accY = 0;
     float to_doY = 0;
     int timesInOk = 0;
     float posX = 0;
     float posY = 0;
     float to_doA = 0;
     float to_doB = 0;
     bool action = true;
     bool girar = false;
     while (action)
     {
     ClearScreen();
         Acquire(semaforo);
         posX = dist * 100;
         posY = angle * 100;
          NumOut(1, LCD_LINE4, posX);
           NumOut(1, LCD_LINE5, posY);
         Release(semaforo);

         errorY = arrayY[nextMovement] - posY;
         errorX = arrayX[nextMovement] - posX;

         NumOut(1, LCD_LINE1, errorX);

         NumOut(1, LCD_LINE2, errorY);
         NumOut(1,LCD_LINE3, nextMovement);

         error_accY = constr(error_accY + errorY, MAX_ACC, -MAX_ACC);
         error_accX = constr(error_accX + errorX, MAX_ACC, -MAX_ACC);

         if(girar)
         {
            if(abs(errorY) < MARGIN){
              if(timesInOk < MARGIN){
                 timesInOk ++;
               } else {
                  if (nextMovement < tam){
                     nextMovement++;
                     girar = false;
                     error_accX = 0;
                     error_accY = 0;
                   } else {
                     action = false;
                   }
                  }
               } else {
                 timesInOk = 0;
               }
           to_doY = errorY*PG + error_accY * IG + (errorY-error_anteriorY)*DG;
         } else {
           if (abs(errorX) < MARGIN){
            if (timesInOk < MARGIN){
             timesInOk ++;
            } else {
            //nexMovement es el medidor del array
              if (nextMovement < tam){
                 nextMovement++;
                 girar = true;
                 error_accX = 0;
                 error_accY = 0;
                } else {
                  action = false;
                }

                timesInOk = 0;
              }
            }else {
                  timesInOk = 0;
            }
            to_doY = errorY*PY + error_accY*IY + (errorY-error_anteriorY) * DY;
           }
           to_doX = errorX*PX + error_accX*IX + (errorX-error_anteriorX) * DX;
           to_doX = constr(to_doX, MAX_GO, -MAX_GO);
           to_doA = to_doX + to_doY;
           to_doB = to_doX - to_doY;
           NumOut(1, LCD_LINE6, to_doA);
           NumOut(1, LCD_LINE7, to_doB);
           if (to_doA > 0){
              OnFwd(MOTORDER, constr(to_doA, MAX_VEL, -MAX_VEL));
           } else {
              OnRev(MOTORDER, constr(-to_doA, MAX_VEL, -MAX_VEL));
           }
           if (to_doB > 0)
           {
              OnFwd(MOTORIZQ, constr(to_doB, MAX_VEL, -MAX_VEL));
           } else {
              OnRev(MOTORIZQ, constr(-to_doB, MAX_VEL, -MAX_VEL));
           }
           error_anteriorY = errorY;
           error_anteriorX = errorX;
           Wait(TIME);
     }
}
void setPosInicial(float xNew, float yNew)
{
     Acquire(semaforo);
     x = xNew;
     y = yNew;
     xDestino = x;
     yDestino = y;
     Release(semaforo);
}
void setPosX(float xNew)
{
     Acquire(semaforo);
     x = xNew;
     Release(semaforo);
}
void setPosY(float yNew)
{
     Acquire(semaforo);
     y = yNew;
     Release(semaforo);
}
void setDestino(float xNew, float yNew)
{
     Acquire(semaforo);
     xDestino = xNew;
     yDestino = yNew;
     //move();
     Release(semaforo);
}



task posicion()
{
     long int d = 0;
     float d_anterior = 0;
     float d_inc = 0;
     long int i = 0;
     float i_anterior = 0;
     float i_inc = 0;
     float theta = 0;
     float distance = 0;
     float new_x = 0;
     float new_y = 0;
     float constante = (2 * PI * RADIO) / 360;
     while(true)
     {
         Wait(TIME);
         d = MotorRotationCount(MOTORDER);
         i = MotorRotationCount(MOTORIZQ);
         d_inc = d - d_anterior;
         i_inc = i - i_anterior;
         d_anterior = d;
         i_anterior = i;
         theta += (constante/D) * (d_inc - i_inc);
         distance = (constante/2) * (d_inc + i_inc);
         new_x = cos(theta)*distance;
         new_y = sin(theta)*distance;
         Acquire(semaforo);
         x += new_x;
         y += new_y;
         angle = theta;
         dist += distance;
         //ClearScreen();
         //NumOut(1, LCD_LINE1, dist);
         //NumOut(1, LCD_LINE2, theta);
         Release(semaforo);

         
     }
}
void goTo(float arrayX[], float arrayY[], int tam)
{
     //Acquire(sMovimiento);
     move();
     //Release(sMovimiento);
}

task movimiento()
{
    goTo(movFichas1X, movFichas1Y, movFichas1Tam);
}

task main()
{

     Precedes(posicion, movimiento);
}

