#define RADIO 0.022
#define D 0.158
#define THRESHOLD 50
#define KP 0
#define KI 0
#define MOTORDER OUT_A
#define MOTORIZQ OUT_C
//Unknow
#define PX 10
#define IX 2
#define DX 0
#define PY 5
#define IY 1
#define DY 0
// Constantes de Giro
#define PG 10
#define IG 1
#define DG 0
#define MARGIN 3



#define TIME 20
#define MAX_ACC 50
#define MAX_VEL 100
#define MAX_GO 60
#define MAX_GIRO 80
#define ESCALE 50
#define X_C 30
#define Y_C 20

#define MAX_TIMER 300

// Definiciones bluetooth
#define INBOX 1
#define OUTBOX 5
#define SLAVE1 "NXT_3"
#define BT_CONN 1

/*Time*/
// PARTE DEL BLUETOOTH BEGIN
// Establecer conexion con el maestro
sub BTCheck(int conn){
    CommBTConnectionType args;
    args.Name = "NXT_3"; // whatever the master NXT's name is
    args.ConnectionSlot = conn; // this is the desired connection slot (the above code uses 1)
    args.Action = TRUE; // could use some #define with a non-zero value to connect.  0 == disconnect
    if(!BluetoothStatus(conn)==NO_ERR)
    {
        SysCommBTConnection(args); // try to connect.
    }
}

// Recibir un numero del maestro
int recibir(int bt_conn){
	int in;
	ReceiveRemoteNumber(INBOX,true,in);
	return in;
}

// Enviar un numero al maestro
void mandar(int msg, int bt_conn){
	SendRemoteNumber(bt_conn, OUTBOX, msg);
}



int constraint (int valor, int max, int min){
    if(valor > max) {
     return max;
    }
    if (valor < min)
    {
     return min;
    }
    return valor;
}

float constr (float valor, float max, float min)
{
      if (valor > max)
         return max;
      if (valor < min)
         return min;
      return valor;
}

mutex semaforo;
mutex sMovimiento;
float x = 0;
float y = 0;
float angle = 0;
float dist = 0;
//Variables destino
float xDestino = 0;
float yDestino = 0;
// Arrays de movimiento para irA
float movFichas1X [4] = {3 , 0, 20, 0};
float movFichas1Y [4] = {0 , 157, 0, 157};
int movFichas1Tam = 4;
int phase = 1;

// Rellenar con mas arrays

void move_1()
{
     int nextMovement = 0;
     int tam = 12;
     //GIRO 90grados = 220
     float arrayX [tam] = {30,20,0,-15,-15,-55,-55,-60,-10,-10,50,110};
     float arrayY [tam] = {0,0,-110,-110,-35,-35,0,0,0,220,220,220};
     bool arrayGiro[tam] = {0,0,1,0,1,0,1,0,0,1,0,0};

     float errorX = 0;
     float error_anteriorX = 0;
     float error_accX = 0;
     float to_doX = 0;
     float errorY = 0;
     float error_anteriorY = 0;
     float error_accY = 0;
     float to_doY = 0;
     int timesInOk = 0;
     float posX = 0;
     float posY = 0;
     float to_doA = 0;
     float to_doB = 0;
     long mA = 0;
     long mB = 0;
     bool action = true;
     unsigned long timer = 0;
     while (action)
     {
         Acquire(semaforo);
         posX = dist * 100;
         posY = angle * 100;
         Release(semaforo);

         errorY = arrayY[nextMovement] - posY;
         errorX = arrayX[nextMovement] - posX;


         error_accY = constr(error_accY + errorY, MAX_ACC, -MAX_ACC);
         error_accX = constr(error_accX + errorX, MAX_ACC, -MAX_ACC);
         NumOut(1,LCD_LINE1,nextMovement);
         NumOut(1,LCD_LINE2,tam);
         if(arrayGiro[nextMovement])
         {
            if(abs(errorY) < MARGIN){
              if(timesInOk < MARGIN){
                 timesInOk ++;
               } else {
                  if (nextMovement < tam-1){
                     nextMovement++;
                     timer=0;
                     error_accX = 0;
                     error_accY = 0;
                   } else {
                     action = false;
                   }
                  }
               } else {
                 timesInOk = 0;
               }
           to_doY = errorY*PG + error_accY * IG + (errorY-error_anteriorY)*DG;
           to_doY = constr (to_doY, MAX_GIRO, -MAX_GIRO);
         } else {
           if (abs(errorX) < MARGIN){
            if (timesInOk < MARGIN){
             timesInOk ++;
            } else {
            //nexMovement es el medidor del array
              if (nextMovement < tam-1){
                 nextMovement++;
                 //nextMovement=1;
                 timer = 0;
                 error_accX = 0;
                 error_accY = 0;
                } else {
                  action = false;
                }

                timesInOk = 0;
              }
            }else {
                  timesInOk = 0;
            }
            to_doY = errorY*PY + error_accY*IY + (errorY-error_anteriorY) * DY;
           }
           to_doX = errorX*PX + error_accX*IX + (errorX-error_anteriorX) * DX;
           to_doX = constr(to_doX, MAX_GO, -MAX_GO);
           to_doA = to_doX + to_doY;
           to_doB = to_doX - to_doY;
           if (to_doA > 0){
              mA = to_doA;
              OnFwd(MOTORDER,constraint(mA, MAX_VEL, -MAX_VEL));
           } else {
           mA=to_doA;
              OnRev(MOTORDER, constraint(-mA, MAX_VEL, -MAX_VEL));
           }

           if (to_doB > 0)
           {
              mB = to_doB;
              OnFwd(MOTORIZQ, constraint(mB, MAX_VEL, -MAX_VEL));
           } else {
              mB = to_doB;
              OnRev(MOTORIZQ, constraint(-mB, MAX_VEL, -MAX_VEL));
           }
           error_anteriorY = errorY;
           error_anteriorX = errorX;
           if (timer > MAX_TIMER){
              nextMovement++;
              timer=0;
              if (nextMovement > tam){
                 action = false;
              }
           }else {
            timer++;
           }
           Wait(TIME);
     }
     OnFwd(MOTORDER, 0);
     OnFwd(MOTORIZQ, 0);
     Wait(TIME);
}

void move_2()
{
     int nextMovement = 0;
     int tam = 1;
     //GIRO 90grados = 220
     float arrayX [tam] = {190};
     float arrayY [tam] = {220};
     bool arrayGiro[tam] = {0};

     float errorX = 0;
     float error_anteriorX = 0;
     float error_accX = 0;
     float to_doX = 0;
     float errorY = 0;
     float error_anteriorY = 0;
     float error_accY = 0;
     float to_doY = 0;
     int timesInOk = 0;
     float posX = 0;
     float posY = 0;
     float to_doA = 0;
     float to_doB = 0;
     long mA = 0;
     long mB = 0;
     bool action = true;
     unsigned long timer = 0;
     while (action)
     {
         Acquire(semaforo);
         posX = dist * 100;
         posY = angle * 100;
         Release(semaforo);

         errorY = arrayY[nextMovement] - posY;
         errorX = arrayX[nextMovement] - posX;


         error_accY = constr(error_accY + errorY, MAX_ACC, -MAX_ACC);
         error_accX = constr(error_accX + errorX, MAX_ACC, -MAX_ACC);
         NumOut(1,LCD_LINE1,nextMovement);
         NumOut(1,LCD_LINE2,tam);
         if(arrayGiro[nextMovement])
         {
            if(abs(errorY) < MARGIN){
              if(timesInOk < MARGIN){
                 timesInOk ++;
               } else {
                  if (nextMovement < tam-1){
                     nextMovement++;
                     timer=0;
                     error_accX = 0;
                     error_accY = 0;
                   } else {
                     action = false;
                   }
                  }
               } else {
                 timesInOk = 0;
               }
           to_doY = errorY*PG + error_accY * IG + (errorY-error_anteriorY)*DG;
           to_doY = constr (to_doY, MAX_GIRO, -MAX_GIRO);
         } else {
           if (abs(errorX) < MARGIN){
            if (timesInOk < MARGIN){
             timesInOk ++;
            } else {
            //nexMovement es el medidor del array
              if (nextMovement < tam-1){
                 nextMovement++;
                 //nextMovement=1;
                 timer = 0;
                 error_accX = 0;
                 error_accY = 0;
                } else {
                  action = false;
                }

                timesInOk = 0;
              }
            }else {
                  timesInOk = 0;
            }
            to_doY = errorY*PY + error_accY*IY + (errorY-error_anteriorY) * DY;
           }
           to_doX = errorX*PX + error_accX*IX + (errorX-error_anteriorX) * DX;
           to_doX = constr(to_doX, MAX_GO, -MAX_GO);
           to_doA = to_doX + to_doY;
           to_doB = to_doX - to_doY;
           if (to_doA > 0){
              mA = to_doA;
              OnFwd(MOTORDER,constraint(mA, MAX_VEL, -MAX_VEL));
           } else {
           mA=to_doA;
              OnRev(MOTORDER, constraint(-mA, MAX_VEL, -MAX_VEL));
           }

           if (to_doB > 0)
           {
              mB = to_doB;
              OnFwd(MOTORIZQ, constraint(mB, MAX_VEL, -MAX_VEL));
           } else {
              mB = to_doB;
              OnRev(MOTORIZQ, constraint(-mB, MAX_VEL, -MAX_VEL));
           }
           error_anteriorY = errorY;
           error_anteriorX = errorX;
           if (timer > MAX_TIMER){
              nextMovement++;
              timer=0;
              if (nextMovement > tam){
                 action = false;
              }
           }else {
            timer++;
           }
           Wait(TIME);
     }
     OnFwd(MOTORDER, 0);
     OnFwd(MOTORIZQ, 0);
     Wait(TIME);
}

void move_3()
{
     int nextMovement = 0;
     int tam = 5;
     //GIRO 90grados = 220
     float arrayX [tam] = {110,90,90,10,10};
     float arrayY [tam] = {220,210,0,0,-210};
     bool arrayGiro[tam] = {0,0,1,0,1};

     float errorX = 0;
     float error_anteriorX = 0;
     float error_accX = 0;
     float to_doX = 0;
     float errorY = 0;
     float error_anteriorY = 0;
     float error_accY = 0;
     float to_doY = 0;
     int timesInOk = 0;
     float posX = 0;
     float posY = 0;
     float to_doA = 0;
     float to_doB = 0;
     long mA = 0;
     long mB = 0;
     bool action = true;
     unsigned long timer = 0;
     while (action)
     {
         Acquire(semaforo);
         posX = dist * 100;
         posY = angle * 100;
         Release(semaforo);

         errorY = arrayY[nextMovement] - posY;
         errorX = arrayX[nextMovement] - posX;


         error_accY = constr(error_accY + errorY, MAX_ACC, -MAX_ACC);
         error_accX = constr(error_accX + errorX, MAX_ACC, -MAX_ACC);
         NumOut(1,LCD_LINE1,nextMovement);
         NumOut(1,LCD_LINE2,tam);
         if(arrayGiro[nextMovement])
         {
            if(abs(errorY) < MARGIN){
              if(timesInOk < MARGIN){
                 timesInOk ++;
               } else {
                  if (nextMovement < tam-1){
                     nextMovement++;
                     timer=0;
                     error_accX = 0;
                     error_accY = 0;
                   } else {
                     action = false;
                   }
                  }
               } else {
                 timesInOk = 0;
               }
           to_doY = errorY*PG + error_accY * IG + (errorY-error_anteriorY)*DG;
           to_doY = constr (to_doY, MAX_GIRO, -MAX_GIRO);
         } else {
           if (abs(errorX) < MARGIN){
            if (timesInOk < MARGIN){
             timesInOk ++;
            } else {
            //nexMovement es el medidor del array
              if (nextMovement < tam-1){
                 nextMovement++;
                 //nextMovement=1;
                 timer = 0;
                 error_accX = 0;
                 error_accY = 0;
                } else {
                  action = false;
                }

                timesInOk = 0;
              }
            }else {
                  timesInOk = 0;
            }
            to_doY = errorY*PY + error_accY*IY + (errorY-error_anteriorY) * DY;
           }
           to_doX = errorX*PX + error_accX*IX + (errorX-error_anteriorX) * DX;
           to_doX = constr(to_doX, MAX_GO, -MAX_GO);
           to_doA = to_doX + to_doY;
           to_doB = to_doX - to_doY;
           if (to_doA > 0){
              mA = to_doA;
              OnFwd(MOTORDER,constraint(mA, MAX_VEL, -MAX_VEL));
           } else {
           mA=to_doA;
              OnRev(MOTORDER, constraint(-mA, MAX_VEL, -MAX_VEL));
           }

           if (to_doB > 0)
           {
              mB = to_doB;
              OnFwd(MOTORIZQ, constraint(mB, MAX_VEL, -MAX_VEL));
           } else {
              mB = to_doB;
              OnRev(MOTORIZQ, constraint(-mB, MAX_VEL, -MAX_VEL));
           }
           error_anteriorY = errorY;
           error_anteriorX = errorX;
           if (timer > MAX_TIMER){
              nextMovement++;
              timer=0;
              if (nextMovement > tam){
                 action = false;
              }
           }else {
            timer++;
           }
           Wait(TIME);
     }
     OnFwd(MOTORDER, 0);
     OnFwd(MOTORIZQ, 0);
     Wait(TIME);
}
void move_4()
{
     int nextMovement = 0;
     int tam = 3;
     //GIRO 90grados = 220
     float arrayX [tam] = {0,-150,-200};
     float arrayY [tam] = {205,205,205};
     bool arrayGiro[tam] = {1,0,0};

     float errorX = 0;
     float error_anteriorX = 0;
     float error_accX = 0;
     float to_doX = 0;
     float errorY = 0;
     float error_anteriorY = 0;
     float error_accY = 0;
     float to_doY = 0;
     int timesInOk = 0;
     float posX = 0;
     float posY = 0;
     float to_doA = 0;
     float to_doB = 0;
     long mA = 0;
     long mB = 0;
     bool action = true;
     unsigned long timer = 0;
     while (action)
     {
         Acquire(semaforo);
         posX = dist * 100;
         posY = angle * 100;
         Release(semaforo);

         errorY = arrayY[nextMovement] - posY;
         errorX = arrayX[nextMovement] - posX;


         error_accY = constr(error_accY + errorY, MAX_ACC, -MAX_ACC);
         error_accX = constr(error_accX + errorX, MAX_ACC, -MAX_ACC);
         NumOut(1,LCD_LINE1,nextMovement);
         NumOut(1,LCD_LINE2,tam);
         if(arrayGiro[nextMovement])
         {
            if(abs(errorY) < MARGIN){
              if(timesInOk < MARGIN){
                 timesInOk ++;
               } else {
                  if (nextMovement < tam-1){
                     nextMovement++;
                     timer=0;
                     error_accX = 0;
                     error_accY = 0;
                   } else {
                     action = false;
                   }
                  }
               } else {
                 timesInOk = 0;
               }
           to_doY = errorY*PG + error_accY * IG + (errorY-error_anteriorY)*DG;
           to_doY = constr (to_doY, MAX_GIRO, -MAX_GIRO);
         } else {
           if (abs(errorX) < MARGIN){
            if (timesInOk < MARGIN){
             timesInOk ++;
            } else {
            //nexMovement es el medidor del array
              if (nextMovement < tam-1){
                 nextMovement++;
                 //nextMovement=1;
                 timer = 0;
                 error_accX = 0;
                 error_accY = 0;
                } else {
                  action = false;
                }

                timesInOk = 0;
              }
            }else {
                  timesInOk = 0;
            }
            to_doY = errorY*PY + error_accY*IY + (errorY-error_anteriorY) * DY;
           }
           to_doX = errorX*PX + error_accX*IX + (errorX-error_anteriorX) * DX;
           to_doX = constr(to_doX, MAX_GO, -MAX_GO);
           to_doA = to_doX + to_doY;
           to_doB = to_doX - to_doY;
           if (to_doA > 0){
              mA = to_doA;
              OnFwd(MOTORDER,constraint(mA, MAX_VEL, -MAX_VEL));
           } else {
           mA=to_doA;
              OnRev(MOTORDER, constraint(-mA, MAX_VEL, -MAX_VEL));
           }

           if (to_doB > 0)
           {
              mB = to_doB;
              OnFwd(MOTORIZQ, constraint(mB, MAX_VEL, -MAX_VEL));
           } else {
              mB = to_doB;
              OnRev(MOTORIZQ, constraint(-mB, MAX_VEL, -MAX_VEL));
           }
           error_anteriorY = errorY;
           error_anteriorX = errorX;
           if (timer > MAX_TIMER){
              nextMovement++;
              timer=0;
              if (nextMovement > tam){
                 action = false;
              }
           }else {
            timer++;
           }
           Wait(TIME);
     }
     OnFwd(MOTORDER, 0);
     OnFwd(MOTORIZQ, 0);
     Wait(TIME);
}
void move_p()
{
     int nextMovement = 0;
     int tam = 1;
     //GIRO 90grados = 220
     float arrayX [tam] = {130};
     float arrayY [tam] = {215};
     bool arrayGiro[tam] = {0};

     float errorX = 0;
     float error_anteriorX = 0;
     float error_accX = 0;
     float to_doX = 0;
     float errorY = 0;
     float error_anteriorY = 0;
     float error_accY = 0;
     float to_doY = 0;
     int timesInOk = 0;
     float posX = 0;
     float posY = 0;
     float to_doA = 0;
     float to_doB = 0;
     long mA = 0;
     long mB = 0;
     bool action = true;
     unsigned long timer = 0;
     while (action)
     {
         Acquire(semaforo);
         posX = dist * 100;
         posY = angle * 100;
         Release(semaforo);

         errorY = arrayY[nextMovement] - posY;
         errorX = arrayX[nextMovement] - posX;


         error_accY = constr(error_accY + errorY, MAX_ACC, -MAX_ACC);
         error_accX = constr(error_accX + errorX, MAX_ACC, -MAX_ACC);
         NumOut(1,LCD_LINE1,nextMovement);
         NumOut(1,LCD_LINE2,tam);
         if(arrayGiro[nextMovement])
         {
            if(abs(errorY) < MARGIN){
              if(timesInOk < MARGIN){
                 timesInOk ++;
               } else {
                  if (nextMovement < tam-1){
                     nextMovement++;
                     timer=0;
                     error_accX = 0;
                     error_accY = 0;
                   } else {
                     action = false;
                   }
                  }
               } else {
                 timesInOk = 0;
               }
           to_doY = errorY*PG + error_accY * IG + (errorY-error_anteriorY)*DG;
           to_doY = constr (to_doY, MAX_GIRO, -MAX_GIRO);
         } else {
           if (abs(errorX) < MARGIN){
            if (timesInOk < MARGIN){
             timesInOk ++;
            } else {
            //nexMovement es el medidor del array
              if (nextMovement < tam-1){
                 nextMovement++;
                 //nextMovement=1;
                 timer = 0;
                 error_accX = 0;
                 error_accY = 0;
                } else {
                  action = false;
                }

                timesInOk = 0;
              }
            }else {
                  timesInOk = 0;
            }
            to_doY = errorY*PY + error_accY*IY + (errorY-error_anteriorY) * DY;
           }
           to_doX = errorX*PX + error_accX*IX + (errorX-error_anteriorX) * DX;
           to_doX = constr(to_doX, MAX_GO, -MAX_GO);
           to_doA = to_doX + to_doY;
           to_doB = to_doX - to_doY;
           if (to_doA > 0){
              mA = to_doA;
              OnFwd(MOTORDER,constraint(mA, MAX_VEL, -MAX_VEL));
           } else {
           mA=to_doA;
              OnRev(MOTORDER, constraint(-mA, MAX_VEL, -MAX_VEL));
           }

           if (to_doB > 0)
           {
              mB = to_doB;
              OnFwd(MOTORIZQ, constraint(mB, MAX_VEL, -MAX_VEL));
           } else {
              mB = to_doB;
              OnRev(MOTORIZQ, constraint(-mB, MAX_VEL, -MAX_VEL));
           }
           error_anteriorY = errorY;
           error_anteriorX = errorX;
           if (timer > MAX_TIMER){
              nextMovement++;
              timer=0;
              if (nextMovement > tam){
                 action = false;
              }
           }else {
            timer++;
           }
           Wait(TIME);
     }
     OnFwd(MOTORDER, 0);
     OnFwd(MOTORIZQ, 0);
     Wait(TIME);
}

void setPosInicial(float xNew, float yNew)
{
     Acquire(semaforo);
     x = xNew;
     y = yNew;
     xDestino = x;
     yDestino = y;
     Release(semaforo);
}
void setPosX(float xNew)
{
     Acquire(semaforo);
     x = xNew;
     Release(semaforo);
}
void setPosY(float yNew)
{
     Acquire(semaforo);
     y = yNew;
     Release(semaforo);
}
void setDestino(float xNew, float yNew)
{
     Acquire(semaforo);
     xDestino = xNew;
     yDestino = yNew;
     //move();
     Release(semaforo);
}



task posicion()
{
     int d = 0;
     float d_anterior = 0;
     float d_inc = 0;
     int i = 0;
     float i_anterior = 0;
     float i_inc = 0;
     float theta = 0;
     float distance = 0;
     float new_x = 0;
     float new_y = 0;
     float constanteAngulo = (2 * PI * RADIO) / (360*D);
     float constanteDistancia = (2 * PI * RADIO) / (360*2);
     while(true)
     {
         Wait(TIME);
         d = MotorRotationCount(MOTORDER);
         i = MotorRotationCount(MOTORIZQ);
         d_inc = d - d_anterior;
         i_inc = i - i_anterior;
         d_anterior = d;
         i_anterior = i;
         theta += constanteAngulo * (d_inc - i_inc);
         distance = constanteDistancia * (d_inc + i_inc);
         new_x = cos(theta)*distance;
         new_y = sin(theta)*distance;
         Acquire(semaforo);
         x += new_x;
         y += new_y;
         angle = theta;
         dist += distance;
         Release(semaforo);
     }
}


// bajar 1
// subir 2
// cerrar 3
// abrir 4
void bajarBrazo()
{
   mandar(1, BT_CONN);
}
void subirBrazo()
{
   mandar(2, BT_CONN);
}
void cerrarPinza()
{
   mandar(3, BT_CONN);
}
void abrirPinza()
{
   mandar(4, BT_CONN);
}

void goTo(float arrayX[], float arrayY[], int tam)
{
     Wait(3000);
     Wait(3000);
     move_1();
     Wait(5000);

     move_p();
     Wait(5000);
     
     move_2();
     Wait(5000);
     
     move_3();
     Wait(8000);
     
     move_4();
     Wait(4000);
     
}

task movimiento()
{
    goTo(movFichas1X, movFichas1Y, movFichas1Tam);
}

task draw()
{
     float x_draw = 0;
     float y_draw = 0;
     while (true){
         Acquire(semaforo);
         x_draw = x;
         y_draw = y;
         Release(semaforo);
         //PointOut (constraint(x_draw*ESCALE+X_C,99,0),constraint(y_draw*ESCALE+Y_C,63,0));
         Wait(75);
     }
}

task main()
{
     //BTCheck(BT_CONN);
     Precedes(posicion, movimiento);
}

